N:genkit
D:Build production-ready AI workflows using Firebase Genkit. Use when creating type-safe flows, tool-calling agents, RAG pipelines, streaming responses, or deploying AI to Firebase/Cloud Run. Supports TypeScript, Go, and Python with Gemini, OpenAI, Anthropic, and Ollama plugins.
G:genkit firebase ai flows agents rag streaming gemini typescript google-cloud llm tool-calling

U[8]:
  **AI Flows**: Wrap LLM logic in type-safe, observable, deployable flow functions
  **Tool Calling / Agents**: Equip models with custom tools and implement agentic loops
  **RAG Pipelines**: Retrieval-augmented generation with Pinecone, pgvector, Firestore, Chroma
  **Streaming**: Real-time token streaming for chat and long-form content
  **Multi-Agent Systems**: Orchestrate multiple specialized AI subflows
  **Prompt Management**: Version-controlled prompts using Dotprompt .prompt files
  **Firebase Deployment**: Deploy flows as Cloud Functions or Cloud Run services
  **Developer UI**: Local visual tool at localhost:4000 for testing, tracing, and debugging

S[6]{n,action,details}:
  1,Install CLI,npm install -g genkit-cli (or: curl -sL cli.genkit.dev | bash)
  2,Create Project,npm init -y && npm install genkit @genkit-ai/google-genai && export GEMINI_API_KEY=...
  3,Initialize Genkit,const ai = genkit({ plugins: [googleAI()], model: googleAI.model('gemini-2.5-flash') })
  4,Define Flow,ai.defineFlow({ name, inputSchema: z.object({...}), outputSchema: z.object({...}) }, async (input) => { ... })
  5,Start Dev UI,genkit start -- npx tsx --watch src/index.ts  → opens http://localhost:4000
  6,Deploy,onCallGenkit() for Firebase Functions / expressHandler() for Express / Cloud Run

R[8]:
  Always define Zod input/output schemas for every flow — enables Dev UI labeled fields and runtime validation
  Use flows for all AI logic — even simple generate() calls benefit from tracing and deployment
  Use ai.run() to wrap non-Genkit code for trace visibility in Dev UI
  Store API keys in env vars; use Firebase Secrets (defineSecret) for production deployments
  Handle null output from generate() — always throw a meaningful error if output is null
  Use streamSchema + sendChunk for long-form content to improve perceived responsiveness
  Set GENKIT_ENV=dev environment variable when running runtime separately from genkit start
  Use onCallGenkit() (not raw Cloud Functions handlers) when deploying flows to Firebase

E[3]{desc,in,out}:
  "Basic flow","ai.defineFlow({ name: 'hello', inputSchema: z.object({ name: z.string() }), outputSchema: z.string() }, async ({ name }) => { const { text } = await ai.generate('Say hello to ' + name); return text; })","Type-safe flow callable as API endpoint with full Dev UI tracing"
  "Tool-calling agent","ai.defineTool({ name: 'getWeather', inputSchema: z.object({ city: z.string() }), outputSchema: z.object({ temp: z.number() }) }, async ({ city }) => fetchWeather(city)) then use tools: [getWeatherTool] in generate()","Agent automatically calls tools and synthesizes final answer"
  "Run flow via CLI","genkit flow:run myFlow '{\"input\": \"value\"}' -s","Executes flow from terminal with streaming output, no server needed"
